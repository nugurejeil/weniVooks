# 리액트 기초 Part.1

# **리액트란 무엇인가?**

react 의 사전적 의미는 “반응하다” 입니다.

즉,

1. HTML 을 보여주고
2. 사용자가 어떤 행동을 하면 그 결과를 HTML에 반영합니다.

이것이 궁극적으로 리액트가 추구하는 목표입니다.

# 리액트가 HTML을 보여주는 방법

## 필요한 모듈과 의미

`npx create-react-app {프로젝트 이름}` 명령어를 실행해서 리액트 프로젝트를 생성하면 index.js 파일안에 아래와 같은 구문이 적혀있습니다.

```jsx
import React from 'react';
import ReactDom from 'react-dom/client';
```

`import React from 'react';`

- 컴포넌트가 무엇인지 그리고 여러 컴포넌트들이 어떻게 서로 작동되게 할 것인지에 대한 정의를 내리는 라이브러리입니다.

`import { ReactDOM } from 'react-dom/client';`

- 컴포넌트를 브라우저에 랜더링하기 위한 라이브러리입니다. 만약 서버사이드 랜더링이 필요하다면 react-dom/server 로 작성합니다.

<aside>
💡 굳이 React와 ReactDOM이 분리된 이유는 리액트가 여러 환경에서 작동되길 원했기 때문입니다. ReactDOM은 브라우저 환경에서, ReactNative는 모바일 디바이스 환경에서 각각 컴포넌트를 랜더링 하는 역할을 수행합니다.

</aside>

## JSX

HTML을 보여주는것은 JSX라는 새로운 문법을 사용합니다. JSX는 HTML과 최대한 유사한 문법으로, 우리가 보여주고 싶은 UI를 리엑트에게 그려달라고 요청할 때 사용합니다.

```jsx
<div className=“box”>
	<h1>hello react!</h1>
</div>
```

### JSX 사용법

- JSX를 리액트에 그려달라고 요청하고 싶을 때 우리는 함수를 생성하여 반환 값에 JSX를 실어 전달합니다. 이렇게 JSX를 반환하는 함수를 우리는 React 컴포넌트라고 합니다.
    
    ```jsx
    function Test() {
      return (
        <div>
          <h2>gooood to see you!</h2>
        </div>
      );
    }
    
    export default Test;
    ```
    
    JSX는 리액트에게 랜더링 해야할 HTML구조를 알려주며, 컴포넌트는 반드시 return 키워드로 JSX를 반환해야만 합니다.
    

- JSX는 자바스크립트의 확장 문법이기 때문에 JSX안에 자바스크립트 표현식을 사용하는게 가능합니다.
    
    ```jsx
    function App() {
    
        const message = "Hi there!";
    
        return <h1>{message ? 'hello there!' : 'good bye'}</h1>
    
    }
    ```
    
    단, 중괄호에 넣어 표현할 수 있는 데이터는 문자열과 숫자형 데이터만 가능합니다. Boolean, array, object, undefined, null 등의 타입들은 리엑트가 어떻게 표현해야할지 모르기 때문에 랜더링 되지 않습니다.
    
- 브라우저는 JSX 문법을 전혀 이해하지 못합니다. 때문에 리액트는 ‘바벨’([https://babeljs.io/](https://babeljs.io/)) 이라는 툴을 이용해 JSX를 JavaScript로 트랜스파일링 합니다.
    
    ```jsx
    <h1>Hi there!</h1> 
    ```
    
    ```jsx
     React.createElement("h1", null, "Hi there!");
    ```
    
    <aside>
    💡 트랜스파일링 (Transpiling)
    한 프로그래밍 언어를 다른 프로그래밍 언어로 변환하는것을 트랜스파일링이라고 합니다. 그리고 그러한 작업을 수행하는 도구를 트랜스파일러(Transpiler) 라 표현합니다.
    
    </aside>
    

- npm start 명령어를 통해 리엑트는
    1. 바벨을 이용해 JSX를 JavaScript로 변경합니다.
    2. 웹팩을 이용해 여러개의 파일들을 하나의 bundle.js로 번들링합니다.
    3. 브라우저는 번들링된 파일을 읽어서 처리합니다.

## **Props System**

부모에서 자식으로 전달하는 데이터를 의미합니다. 자식들마다 다른 데이터를 전달하도록 설정하는게 가능하며, 일반적으로 부모에서 자식 방향으로만 전달 가능합니다.

### **Props의 사용법**

1. JSX에 속성의 형태로 사용합니다.
    
    ```jsx
    import Card from "./Card";
    
    function App() {
    
        return (
            <>
                <div>World Most Cuttest Animals</div>
    
                <Card title="랫서판다" text="레서판다는 작은 판다라는 의미에서 Lesser Panda라고 불리게 됐습니다" />
                <Card title="사막여우" text="열을 배출하기 위해 발달된 널찍한 귀가 특징입니다." />
                <Card title="북극여우" text="여름에는 꼬리와 다리는 갈색, 옆구리와 배는 밝은 베이지색 털로 털갈이를 합니다." />
            </>
        );
    }
    
    export default App;
    ```
    
2. React는 속성을 모아 하나의 객체로 만들어 전달합니다.
3. Props 를 전달받는 자식 컴포넌트는 컴포넌트 함수의 첫번째 인자로 Props 객체를 전달받습니다.
    
    ```jsx
    function Card(props) {
        return (
            <figure>
                <figcaption>
                    <strong>{props.title}</strong>
                    <p>{props.text}</p>
                </figcaption>
            </figure>
        )
    }
    
    export default Card;
    ```
    
4. 구조분해할당을 이용하면 더 단순한 형태로 표현이 가능합니다.
    
    ```jsx
    function Card({title, text}) {
        return (
            <figure>
                <figcaption>
                    <strong>{title}</strong>
                    <p>{text}</p>
                </figcaption>
            </figure>
        )
    }
    
    export default Card;
    ```
    

## 컴포넌트에 스타일 적용하기

### 1. CSS 프레임워크 스타일 적용하기 <Tailwind CSS>

- npm 으로 설치하고 초기화합니다.

```bash
npm install -D tailwindcss postcss autoprefixer
```

```bash
npx tailwindcss init -p
```

- 초기화 하면 tailwind.config.js 파일이 생성됩니다. 아래 코드를 추가합니다.

```bash
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

- index.css 파일에 코드를 추가하고 프로젝트를 다시 빌드합니다.

```bash
@tailwind base;
@tailwind components;
@tailwind utilities;
```

- 이제 프로젝트 안에서 Tailwind CSS를 사용할 수 있습니다.

```jsx
export default function App() {
  return (
    <h1 className="text-3xl font-bold underline">
      Hello world!
    </h1>
  )
}
```

### 2. 일반적인 CSS 적용하기

- 컴포넌트에 적용할 CSS 파일을 생성합니다.

```css
.w-full {
    width: 50%;
}
```

- 적용하고자 하는 컴포넌트에 CSS 파일을 import 합니다.

```
import './card.css';

function Card({ title, text, imgUrl }) {
    return (
        <figure className={`w-1/3 px-3 rounded overflow-hidden shadow-lg`}>
            <img className="w-full h-48 object-cover object-top" src={imgUrl} alt="" />
            <figcaption className="px-6 py-4">
								<strong className="font-bold text-xl mb-2">{title}</strong>
                <p className="text-gray-700 text-base">{text}</p>
            </figcaption>
				</figure> */}
    )
}

export default Card;
```

- 스타일이 잘 적용됩니다. 다만 이런 방법은 동일한 클래스 네이밍 충돌의 위험성이 있습니다. 때문에 의도하지않은 엉뚱한 스타일이 적용될 수 있습니다.
    
    ![스크린샷_2022-12-23_오전_11.49.09.png](%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-12-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.49.09.png)
    

### 3. 모듈 CSS 적용하기

- 컴포넌트에 적용할 모듈 파일을 생성합니다. 이때 파일 이름 중간에 반드시 module 키워드가 존재해야합니다.

```css
.rounded {
    border-radius: 0.75rem;
}
```

- 적용하고자 하는 컴포넌트에 CSS 파일을 import 합니다. JSX안에 표시하기 위해 중괄호를 사용합니다.

```
import style from './Card.module.css';

function Card({ title, text, imgUrl }) {
    return (
        <figure className={`w-1/3 px-3 rounded ${style.rounded} overflow-hidden shadow-lg`}>
            <img className="w-full h-48 object-cover object-top" src={imgUrl} alt="" />
            <figcaption>
                <strong>{title}</strong>
                <p>{text}</p>
            </figcaption>
        </figure>
    )
}
```

- 스타일이 잘 적용됩니다. 모듈 방법은 동일한 클래스 네이밍을 이용하는 스타일이 있다고 해도 번들링과 동시에 클래스 이름에 임의의 난수값을 추가합니다. 덕분에 중복된 클래스 이름 때문에 의도치 않은 스타일이 적용될 일이 없게 됩니다.
    
    ![아래 이미지가 번들링된 결과물입니다. rounded 는 컴포넌트에 표기된 클래스 이름. Card_rounded__TNV5Y 는 번들링을 통해 변경된 모듈 CSS 파일 안의 클래스 이름입니다.](Untitled%2081.png)
    
    아래 이미지가 번들링된 결과물입니다. rounded 는 컴포넌트에 표기된 클래스 이름. Card_rounded__TNV5Y 는 번들링을 통해 변경된 모듈 CSS 파일 안의 클래스 이름입니다.
    

### 4. styledComponent 적용하기

- 프로젝트에 styledComponent를 설치합니다.

```bash
npm i styled-components
```

- 스타일을 적용하고 싶은 컴포넌트 파일에 styledComponent 모듈을 불러옵니다.

```
import styled from 'styled-components';
```

- 원하는 CSS 스타일을 작성합니다.
    - 스타일을 작성할때는 styledComponent 객체(`styled`)를 통해 작성합니다.
    - 우리가 랜더링 하고자 하는 요소(`figure`)를 styled 객체의 속성으로 등록합니다.
    - 등록된 figure 속성은 styledComponent 함수로서 뒤이어 사용되는 템플릿 리터럴을 매개변수로 하여 실행됩니다. 이를 태그된 템플릿([Tagged templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates)) 이라고 표현합니다.
    - 템플릿 리터럴 안에는 우리가 사용하고자 하는 CSS 속성을 CSS 문법 그대로 사용합니다.
    
    ```jsx
    const Figure = styled.figure`
            border-radius: 0.9rem;
        `;
    ```
    

- 등록한 속성의 이름을 컴포넌트 처럼 사용합니다. 때문에 태그된 템플릿안에서 props 로 컴포넌트의 속성값에 접근할 수 있습니다. 이를 통해 전달하는 props 값에 따른 스타일을 구축할 수 있습니다.
    
    ```jsx
    import styled from 'styled-components';
    
    const Figure = styled.figure`
            border-radius: 0.9rem;
        `;
    
    const Strong = styled.strong`
             color: ${props => props.txtColor}
        `;
    
    function Card({ title, text, imgUrl }) {
    
        const txtColor = title === '랫서판다' ? 'red' : title === '북극여우' ? 'blue' : 'yellow';
    
        return (
            <Figure className="w-1/3 px-3 rounded overflow-hidden shadow-lg">
                <img className="w-full h-48 object-cover object-top" src={imgUrl} alt="" />
                <figcaption className="px-6 py-4">
                    <Strong txtColor={txtColor} className="font-bold text-xl mb-2">{title}</Strong>
                    <p className="text-gray-700 text-base">{text}</p>
                </figcaption>
            </Figure>
        )
    }
    
    export default Card;
    ```
    
    <aside>
    💡 태그된 템플릿([Tagged templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates))
    함수 뒤에 템플릿리터럴을 붙이면, 붙여준 템플릿리터럴을 원소로하는 배열을 첫번째 인자로 함수가 실행되도록 합니다.
    이때 실행되는 함수를 태그 함수, 사용된 템플릿리터럴을 태그된 템플릿이라 부릅니다.
    
    ```jsx
    function test(str){
      return str
    }
    
    console.log(test`world`); // 반환값은 ['world'] 입니다.
    ```
    
    </aside>
    
- 등록된 결과물은 확인해보면 styled 객체를 통해 등록한 스타일에 난독화된 클래스 이름이 적용되어 있는 것을 확인할 수 있습니다. 그리고 스타일이 적혀있는 리소스의 위치도 보이지 않게 합니다.
    
    ![스크린샷 2022-12-23 오후 9.56.53.png](%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-12-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.56.53.png)
    
    ![스크린샷 2022-12-23 오후 9.58.19.png](%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-12-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.58.19.png)
    
    styledComponent 를 이용하면 아래와 같은 장점을 가집니다.
    
    1. JS 안에 CSS 문법을 작성할 수 있어 편리하고 CSS 스타일의 내용을 즉각적으로 확인할 수 있습니다.
    2. 클래스 네이밍 난독화를 통해 클래스 네이밍 중복을 막습니다.