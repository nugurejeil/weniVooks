---
chapter: 자료구조
title: 힙
date: 2024-11-19
---

# 1. 힙 (Heap)

힙은 **완전 이진 트리 기반의 자료구조**로, 부모 노드와 자식 노드 간에 특정한 순서 관계가 있습니다. 주로 **우선순위 큐**를 구현하는 데 사용됩니다.

## 1.1 힙의 특징

- **완전 이진 트리**: 마지막 레벨을 제외하고 모든 레벨이 채워져 있고, 마지막 레벨은 왼쪽부터 채워짐
- **힙 속성**: 부모 노드가 자식 노드보다 항상 크거나(최대 힙) 작음(최소 힙)
- **최댓값/최솟값 빠른 접근**: O(1) 시간에 최댓값 또는 최솟값 조회
- **효율적인 삽입/삭제**: O(log n) 시간에 삽입과 삭제

## 1.2 최소 힙 vs 최대 힙

### 1.2.1 최소 힙 (Min Heap)

부모 노드가 자식 노드보다 항상 작거나 같은 힙입니다.

```mermaid
graph TD
    A["1<br/>(최솟값)"] --> B["3"]
    A --> C["2"]
    B --> D["7"]
    B --> E["5"]
    C --> F["4"]
    C --> G["6"]

    style A fill:#c8e6c9
    style B fill:#e1f5ff
    style C fill:#e1f5ff
    style D fill:#fff4c1
    style E fill:#fff4c1
    style F fill:#fff4c1
    style G fill:#fff4c1
```

**특징**: 루트 노드가 전체 힙에서 가장 작은 값

### 1.2.2 최대 힙 (Max Heap)

부모 노드가 자식 노드보다 항상 크거나 같은 힙입니다.

```mermaid
graph TD
    A["10<br/>(최댓값)"] --> B["8"]
    A --> C["9"]
    B --> D["3"]
    B --> E["5"]
    C --> F["6"]
    C --> G["7"]

    style A fill:#ffe1e1
    style B fill:#e1f5ff
    style C fill:#e1f5ff
    style D fill:#fff4c1
    style E fill:#fff4c1
    style F fill:#fff4c1
    style G fill:#fff4c1
```

**특징**: 루트 노드가 전체 힙에서 가장 큰 값

## 1.3 힙의 배열 표현

힙은 완전 이진 트리이므로 배열로 효율적으로 표현할 수 있습니다.

```python
# 최소 힙: [1, 3, 2, 7, 5, 4, 6]
# 인덱스:   0  1  2  3  4  5  6

# 인덱스 i인 노드의:
# - 부모 인덱스: (i - 1) // 2
# - 왼쪽 자식 인덱스: 2 * i + 1
# - 오른쪽 자식 인덱스: 2 * i + 2

# 예시: 인덱스 1 (값: 3)
parent = (1 - 1) // 2        # 0 (값: 1)
left_child = 2 * 1 + 1       # 3 (값: 7)
right_child = 2 * 1 + 2      # 4 (값: 5)
```

```mermaid
graph LR
    A["배열 표현"] --> B["트리 형태"]

    style A fill:#e1f5ff
    style B fill:#c8e6c9
```

**배열**: `[1, 3, 2, 7, 5, 4, 6]`

**트리**:
```
       1 (i=0)
      / \
     3   2 (i=1,2)
    / \ / \
   7  5 4  6 (i=3,4,5,6)
```

# 2. 힙의 연산

## 2.1 삽입 (Insert)

새로운 요소를 힙의 마지막에 추가한 후, 힙 속성을 만족할 때까지 위로 이동시킵니다.

```python
def heappush(heap, item):
    """최소 힙에 요소 삽입"""
    heap.append(item)  # 마지막에 추가
    _sift_up(heap, len(heap) - 1)  # 위로 이동

def _sift_up(heap, index):
    """힙 속성을 만족할 때까지 위로 이동"""
    parent = (index - 1) // 2

    # 부모가 있고, 부모보다 작으면 교환
    if index > 0 and heap[index] < heap[parent]:
        heap[index], heap[parent] = heap[parent], heap[index]
        _sift_up(heap, parent)  # 재귀적으로 위로 이동
```

**삽입 과정**:

```mermaid
graph TD
    A["1. 마지막에 추가"] --> B["2. 부모와 비교"]
    B --> C["3. 작으면 교환"]
    C --> D["4. 루트 도달 or<br/>부모보다 크면 완료"]

    style A fill:#e1f5ff
    style D fill:#c8e6c9
```

**시간복잡도**: O(log n) - 트리의 높이만큼 이동

## 2.2 삭제 (Delete)

루트 노드(최솟값 또는 최댓값)를 제거하고, 마지막 요소를 루트로 이동시킨 후 아래로 내립니다.

```python
def heappop(heap):
    """최소 힙에서 최솟값 제거하고 반환"""
    if not heap:
        raise IndexError("heap is empty")

    # 루트와 마지막 요소 교환
    heap[0], heap[-1] = heap[-1], heap[0]
    min_value = heap.pop()  # 마지막 요소(원래 루트) 제거

    # 새로운 루트를 아래로 내림
    if heap:
        _sift_down(heap, 0)

    return min_value

def _sift_down(heap, index):
    """힙 속성을 만족할 때까지 아래로 이동"""
    left = 2 * index + 1
    right = 2 * index + 2
    smallest = index

    # 왼쪽 자식이 더 작으면
    if left < len(heap) and heap[left] < heap[smallest]:
        smallest = left

    # 오른쪽 자식이 더 작으면
    if right < len(heap) and heap[right] < heap[smallest]:
        smallest = right

    # 자식 중 하나가 더 작으면 교환
    if smallest != index:
        heap[index], heap[smallest] = heap[smallest], heap[index]
        _sift_down(heap, smallest)  # 재귀적으로 아래로 이동
```

**시간복잡도**: O(log n) - 트리의 높이만큼 이동

# 3. Python heapq 모듈

Python은 최소 힙을 구현한 `heapq` 모듈을 제공합니다.

## 3.1 기본 사용법

```python
import heapq

# 빈 힙 생성
heap = []

# 요소 추가 (최소 힙)
heapq.heappush(heap, 5)
heapq.heappush(heap, 3)
heapq.heappush(heap, 7)
heapq.heappush(heap, 1)
print(heap)  # [1, 3, 7, 5] (힙 구조)

# 최솟값 조회 (제거 X)
min_value = heap[0]
print(min_value)  # 1

# 최솟값 제거 및 반환
min_value = heapq.heappop(heap)
print(min_value)  # 1
print(heap)       # [3, 5, 7]

# 리스트를 힙으로 변환
numbers = [5, 3, 7, 1, 9, 2]
heapq.heapify(numbers)  # O(n) 시간
print(numbers)  # [1, 3, 2, 5, 9, 7] (힙 구조)
```

## 3.2 최대 힙 구현

Python의 heapq는 최소 힙만 제공하므로, 최대 힙은 값을 음수로 변환하여 구현합니다.

```python
import heapq

# 최대 힙
max_heap = []

# 요소 추가 (음수로 변환)
heapq.heappush(max_heap, -5)
heapq.heappush(max_heap, -3)
heapq.heappush(max_heap, -7)
heapq.heappush(max_heap, -1)
print(max_heap)  # [-7, -3, -5, -1]

# 최댓값 제거 및 반환 (음수를 다시 양수로)
max_value = -heapq.heappop(max_heap)
print(max_value)  # 7
```

## 3.3 유용한 heapq 함수들

```python
import heapq

# n개의 최솟값 찾기
numbers = [5, 3, 7, 1, 9, 2, 8, 4, 6]
smallest_3 = heapq.nsmallest(3, numbers)
print(smallest_3)  # [1, 2, 3]

# n개의 최댓값 찾기
largest_3 = heapq.nlargest(3, numbers)
print(largest_3)  # [9, 8, 7]

# 두 힙 병합
heap1 = [1, 3, 5]
heap2 = [2, 4, 6]
heapq.heapify(heap1)
heapq.heapify(heap2)

merged = []
while heap1 and heap2:
    if heap1[0] < heap2[0]:
        merged.append(heapq.heappop(heap1))
    else:
        merged.append(heapq.heappop(heap2))

merged.extend(heap1 or heap2)
print(merged)  # [1, 2, 3, 4, 5, 6]
```

# 4. 우선순위 큐 (Priority Queue)

우선순위 큐는 **각 요소가 우선순위를 가지며, 우선순위가 높은 요소가 먼저 나가는 자료구조**입니다. 힙으로 구현하면 효율적입니다.

## 4.1 우선순위 큐 구현

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.heap = []
        self.counter = 0  # 같은 우선순위일 때 삽입 순서 보장

    def push(self, item, priority):
        """우선순위와 함께 요소 추가 (낮은 값이 높은 우선순위)"""
        # (우선순위, 삽입순서, 값) 튜플로 저장
        heapq.heappush(self.heap, (priority, self.counter, item))
        self.counter += 1

    def pop(self):
        """가장 높은 우선순위 요소 제거 및 반환"""
        if not self.heap:
            raise IndexError("Priority queue is empty")
        priority, _, item = heapq.heappop(self.heap)
        return item

    def peek(self):
        """가장 높은 우선순위 요소 조회 (제거 X)"""
        if not self.heap:
            raise IndexError("Priority queue is empty")
        priority, _, item = self.heap[0]
        return item

    def is_empty(self):
        return len(self.heap) == 0

    def size(self):
        return len(self.heap)

# 사용 예제
pq = PriorityQueue()
pq.push("작업 A", priority=3)
pq.push("작업 B", priority=1)  # 가장 높은 우선순위
pq.push("작업 C", priority=2)

print(pq.pop())  # "작업 B" (우선순위 1)
print(pq.pop())  # "작업 C" (우선순위 2)
print(pq.pop())  # "작업 A" (우선순위 3)
```

# 5. 실전 활용 예제

## 5.1 더 맵게

모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 구하는 문제입니다.
- 섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식 + (두 번째로 맵지 않은 음식 × 2)

```python
import heapq

def solution(scoville, K):
    """
    접근 방법: 최소 힙 활용
    - 최소 힙으로 가장 맵지 않은 음식 빠르게 찾기
    - 조건을 만족할 때까지 섞기 반복

    시간복잡도: O(n log n)
    공간복잡도: O(1)
    """
    heapq.heapify(scoville)  # 리스트를 힙으로 변환
    mix_count = 0

    while scoville[0] < K:
        # 음식이 1개만 남았는데 K 미만이면 불가능
        if len(scoville) < 2:
            return -1

        # 가장 맵지 않은 두 음식 꺼내기
        first = heapq.heappop(scoville)
        second = heapq.heappop(scoville)

        # 새로운 음식 만들어 추가
        new_scoville = first + (second * 2)
        heapq.heappush(scoville, new_scoville)

        mix_count += 1

    return mix_count

# 테스트
scoville = [1, 2, 3, 9, 10, 12]
K = 7
print(solution(scoville, K))  # 2
# 설명:
# 1차: 1 + (2 × 2) = 5, [3, 5, 9, 10, 12]
# 2차: 3 + (5 × 2) = 13, [9, 10, 12, 13]
# 모든 음식이 7 이상
```

## 5.2 디스크 컨트롤러

하드디스크가 작업을 수행하는 평균 시간을 최소화하는 문제입니다.

```python
import heapq

def solution(jobs):
    """
    접근 방법: 우선순위 큐 (최소 힙)
    - 현재 시점에 요청된 작업 중 소요 시간이 짧은 것부터 처리
    - SJF (Shortest Job First) 스케줄링

    시간복잡도: O(n log n)
    공간복잡도: O(n)
    """
    jobs.sort()  # 요청 시간 순으로 정렬
    current_time = 0
    total_time = 0
    job_index = 0
    n = len(jobs)
    heap = []

    while job_index < n or heap:
        # 현재 시점까지 요청된 작업들을 힙에 추가
        while job_index < n and jobs[job_index][0] <= current_time:
            # (소요시간, 요청시간) 형태로 저장 (소요시간 기준 최소 힙)
            heapq.heappush(heap, (jobs[job_index][1], jobs[job_index][0]))
            job_index += 1

        if heap:
            # 소요 시간이 가장 짧은 작업 처리
            duration, request_time = heapq.heappop(heap)
            current_time += duration
            total_time += current_time - request_time
        else:
            # 처리할 작업이 없으면 다음 작업 요청 시간으로 이동
            current_time = jobs[job_index][0]

    return total_time // n

# 테스트
jobs = [[0, 3], [1, 9], [2, 6]]
print(solution(jobs))  # 9
# 설명:
# 0ms: [0,3] 시작 → 3ms 완료 (대기: 3ms)
# 3ms: [2,6] 시작 (소요시간 6 < 9) → 9ms 완료 (대기: 9-2=7ms)
# 9ms: [1,9] 시작 → 18ms 완료 (대기: 18-1=17ms)
# 평균: (3+7+17)/3 = 9
```

## 5.3 이중 우선순위 큐

최댓값과 최솟값을 모두 삭제할 수 있는 이중 우선순위 큐를 구현하는 문제입니다.

```python
import heapq
from collections import defaultdict

def solution(operations):
    """
    접근 방법: 최소 힙과 최대 힙 동시 사용
    - 최소 힙: 최솟값 빠르게 제거
    - 최대 힙: 최댓값 빠르게 제거
    - 동기화: 삭제된 값은 양쪽에서 모두 제거

    시간복잡도: O(n log n)
    공간복잡도: O(n)
    """
    min_heap = []
    max_heap = []
    counter = defaultdict(int)  # 각 값의 개수 추적

    for op in operations:
        cmd, num = op.split()
        num = int(num)

        if cmd == 'I':
            # 삽입: 양쪽 힙에 모두 추가
            heapq.heappush(min_heap, num)
            heapq.heappush(max_heap, -num)
            counter[num] += 1

        elif cmd == 'D':
            if num == 1:
                # 최댓값 삭제
                while max_heap and counter[-max_heap[0]] == 0:
                    heapq.heappop(max_heap)
                if max_heap:
                    max_val = -heapq.heappop(max_heap)
                    counter[max_val] -= 1
            else:
                # 최솟값 삭제
                while min_heap and counter[min_heap[0]] == 0:
                    heapq.heappop(min_heap)
                if min_heap:
                    min_val = heapq.heappop(min_heap)
                    counter[min_val] -= 1

    # 유효한 값들만 남기기
    while min_heap and counter[min_heap[0]] == 0:
        heapq.heappop(min_heap)
    while max_heap and counter[-max_heap[0]] == 0:
        heapq.heappop(max_heap)

    if not min_heap or not max_heap:
        return [0, 0]

    return [-max_heap[0], min_heap[0]]

# 테스트
operations = ["I 16", "I -5643", "D -1", "D 1", "D 1", "I 123", "D -1"]
print(solution(operations))  # [0, 0]

operations = ["I -45", "I 653", "D 1", "I -642", "I 45", "I 97", "D 1", "D -1", "I 333"]
print(solution(operations))  # [333, -45]
```

## 5.4 K번째 큰 요소 찾기

정렬되지 않은 배열에서 K번째로 큰 요소를 찾는 문제입니다.

```python
import heapq

def find_kth_largest(nums, k):
    """
    접근 방법 1: 최소 힙 유지
    - 크기가 k인 최소 힙 유지
    - 힙의 최솟값이 k번째로 큰 값

    시간복잡도: O(n log k)
    공간복잡도: O(k)
    """
    heap = []

    for num in nums:
        heapq.heappush(heap, num)
        # 힙 크기가 k를 초과하면 최솟값 제거
        if len(heap) > k:
            heapq.heappop(heap)

    # 힙의 최솟값이 k번째로 큰 값
    return heap[0]

# 다른 접근: nlargest 활용
def find_kth_largest_v2(nums, k):
    """
    접근 방법 2: heapq.nlargest 활용

    시간복잡도: O(n log k)
    공간복잡도: O(k)
    """
    return heapq.nlargest(k, nums)[-1]

# 테스트
nums = [3, 2, 1, 5, 6, 4]
k = 2
print(find_kth_largest(nums, k))  # 5 (2번째로 큰 값)

nums = [3, 2, 3, 1, 2, 4, 5, 5, 6]
k = 4
print(find_kth_largest(nums, k))  # 4 (4번째로 큰 값)
```

# 6. 힙 사용 시나리오

## 6.1 힙이 적합한 경우

- **최댓값/최솟값을 자주 찾을 때**
  - K번째로 큰/작은 요소 찾기
  - 중간값 유지

- **우선순위 기반 처리**
  - 작업 스케줄링
  - 이벤트 관리

- **정렬이 필요하지만 전체 정렬은 비효율적일 때**
  - 상위 K개만 필요한 경우
  - 힙 정렬 (Heap Sort)

- **다익스트라 알고리즘**
  - 최단 경로 찾기

## 6.2 힙이 부적합한 경우

- **임의의 요소 검색**
  - O(n) 시간 소요, 해시 테이블이 더 적합

- **모든 요소 정렬 필요**
  - 일반 정렬 알고리즘 사용

- **FIFO/LIFO 순서 필요**
  - 큐/스택 사용

# 7. 힙의 시간복잡도

| 연산 | 시간복잡도 | 설명 |
|------|-----------|------|
| **최댓값/최솟값 조회** | O(1) | 루트 노드 접근 |
| **삽입 (heappush)** | O(log n) | 트리 높이만큼 이동 |
| **삭제 (heappop)** | O(log n) | 트리 높이만큼 이동 |
| **힙 생성 (heapify)** | O(n) | 상향식 힙 구성 |
| **K개 최댓값/최솟값** | O(n log k) | 크기 k인 힙 유지 |

# 8. 핵심 정리

:::div{.callout}
**힙 핵심 포인트**

**기본 개념**
- 완전 이진 트리 기반
- 부모 ≤ 자식 (최소 힙) 또는 부모 ≥ 자식 (최대 힙)
- 배열로 효율적 표현
- 인덱스 i의 부모: (i-1)//2, 자식: 2i+1, 2i+2

**시간복잡도**
- 최댓값/최솟값 조회: O(1)
- 삽입: O(log n)
- 삭제: O(log n)
- 힙 생성 (heapify): O(n)

**Python 구현**
- `heapq` 모듈 사용 (최소 힙)
- 최대 힙: 음수로 변환
- 주요 함수: `heappush`, `heappop`, `heapify`, `nsmallest`, `nlargest`

**활용 시나리오**
- 우선순위 큐
- K번째 큰/작은 요소
- 작업 스케줄링
- 최단 경로 알고리즘 (다익스트라)
- 중간값 유지 (두 힙 사용)

**코딩테스트 팁**
- 최댓값/최솟값을 반복적으로 찾는다면 힙 고려
- 정렬 대신 힙으로 O(n log n) → O(n log k) 개선 가능
- 이중 우선순위 큐: 최소 힙 + 최대 힙 동시 사용
- 상위 K개만 필요하면 크기 k인 힙 유지
:::
