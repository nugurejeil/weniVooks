---
chapter: 자료구조
title: 힙
date: 2024-11-19
---

# 1. 학습목표

- 힙의 개념과 특징을 이해한다.
- 최소 힙과 최대 힙의 차이를 이해한다.
- Python heapq 모듈을 활용할 수 있다.
- 우선순위 큐의 개념을 이해한다.
- 실전 문제에서 힙을 효과적으로 활용할 수 있다.

# 2. 힙(Heap)이란?

힙은 **완전 이진 트리 기반의 자료구조**로, 부모 노드와 자식 노드 간에 특정한 순서 관계가 있습니다. 주로 **우선순위 큐**를 구현하는 데 사용됩니다.

## 2.1 힙의 특징

- **완전 이진 트리**: 마지막 레벨을 제외하고 모든 레벨이 채워져 있고, 마지막 레벨은 왼쪽부터 채워짐
- **힙 속성**: 부모 노드가 자식 노드보다 항상 크거나(최대 힙) 작음(최소 힙)
- **최댓값/최솟값 빠른 접근**: O(1) 시간에 최댓값 또는 최솟값 조회
- **효율적인 삽입/삭제**: O(log n) 시간에 삽입과 삭제

## 2.2 최소 힙 vs 최대 힙

### 2.2.1 최소 힙 (Min Heap)
부모 노드가 자식 노드보다 항상 작거나 같은 힙입니다.

```mermaid
graph TD
    A["1<br/>(최솟값)"] --> B["3"]
    A --> C["2"]
    B --> D["7"]
    B --> E["5"]
    C --> F["4"]
    C --> G["6"]

    style A fill:#c8e6c9
    style B fill:#e1f5ff
    style C fill:#e1f5ff
    style D fill:#fff4c1
    style E fill:#fff4c1
    style F fill:#fff4c1
    style G fill:#fff4c1
```

**특징**: 루트 노드가 전체 힙에서 가장 작은 값

### 2.2.2 최대 힙 (Max Heap)
부모 노드가 자식 노드보다 항상 크거나 같은 힙입니다.

```mermaid
graph TD
    A["10<br/>(최댓값)"] --> B["8"]
    A --> C["9"]
    B --> D["3"]
    B --> E["5"]
    C --> F["6"]
    C --> G["7"]

    style A fill:#ffe1e1
    style B fill:#e1f5ff
    style C fill:#e1f5ff
    style D fill:#fff4c1
    style E fill:#fff4c1
    style F fill:#fff4c1
    style G fill:#fff4c1
```

**특징**: 루트 노드가 전체 힙에서 가장 큰 값

## 2.3 힙의 배열 표현

힙은 완전 이진 트리이므로 배열로 효율적으로 표현할 수 있습니다.

```python
# 3. 최소 힙: [1, 3, 2, 7, 5, 4, 6]
# 4. 인덱스:   0  1  2  3  4  5  6

# 5. 인덱스 i인 노드의:
# 6. - 부모 인덱스: (i - 1) // 2
# 7. - 왼쪽 자식 인덱스: 2 * i + 1
# 8. - 오른쪽 자식 인덱스: 2 * i + 2

# 9. 예시: 인덱스 1 (값: 3)
parent = (1 - 1) // 2        # 0 (값: 1)
left_child = 2 * 1 + 1       # 3 (값: 7)
right_child = 2 * 1 + 2      # 4 (값: 5)
```

```mermaid
graph TB
    subgraph "배열 표현"
    A["인덱스: 0, 1, 2, 3, 4, 5, 6<br/>값: [1, 3, 2, 7, 5, 4, 6]"]
    end

    subgraph "트리 형태"
    B["1<br/>(i=0)"] --> C["3<br/>(i=1)"]
    B --> D["2<br/>(i=2)"]
    C --> E["7<br/>(i=3)"]
    C --> F["5<br/>(i=4)"]
    D --> G["4<br/>(i=5)"]
    D --> H["6<br/>(i=6)"]
    end

    style B fill:#c8e6c9
```

# 10. 힙의 연산

## 10.1 삽입 (Insert)

새로운 요소를 힙의 마지막에 추가한 후, 힙 속성을 만족할 때까지 위로 이동시킵니다.

```python
def heappush(heap, item):
    """최소 힙에 요소 삽입"""
    heap.append(item)  # 마지막에 추가
    _sift_up(heap, len(heap) - 1)  # 위로 이동

def _sift_up(heap, index):
    """힙 속성을 만족할 때까지 위로 이동"""
    parent = (index - 1) // 2

    # 부모가 있고, 부모보다 작으면 교환
    if index > 0 and heap[index] < heap[parent]:
        heap[index], heap[parent] = heap[parent], heap[index]
        _sift_up(heap, parent)  # 재귀적으로 위로 이동
```

**삽입 과정 시각화**:

```mermaid
graph TB
    A["1. 마지막에 추가<br/>[1, 3, 2, 7, 5, 4, 6, 0]"] --> B["2. 부모(3)와 비교<br/>0 < 3이므로 교환"]
    B --> C["3. [1, 0, 2, 7, 5, 4, 6, 3]<br/>부모(1)와 비교"]
    C --> D["4. 0 < 1이므로 교환<br/>[0, 1, 2, 7, 5, 4, 6, 3]"]
    D --> E["5. 루트 도달, 완료"]

    style A fill:#e1f5ff
    style E fill:#c8e6c9
```

**시간복잡도**: O(log n) - 트리의 높이만큼 이동

## 10.2 삭제 (Delete)

루트 노드(최솟값 또는 최댓값)를 제거하고, 마지막 요소를 루트로 이동시킨 후 아래로 내립니다.

```python
def heappop(heap):
    """최소 힙에서 최솟값 제거하고 반환"""
    if not heap:
        raise IndexError("heap is empty")

    # 루트와 마지막 요소 교환
    heap[0], heap[-1] = heap[-1], heap[0]
    min_value = heap.pop()  # 마지막 요소(원래 루트) 제거

    # 새로운 루트를 아래로 내림
    if heap:
        _sift_down(heap, 0)

    return min_value

def _sift_down(heap, index):
    """힙 속성을 만족할 때까지 아래로 이동"""
    left = 2 * index + 1
    right = 2 * index + 2
    smallest = index

    # 왼쪽 자식이 더 작으면
    if left < len(heap) and heap[left] < heap[smallest]:
        smallest = left

    # 오른쪽 자식이 더 작으면
    if right < len(heap) and heap[right] < heap[smallest]:
        smallest = right

    # 자식 중 하나가 더 작으면 교환
    if smallest != index:
        heap[index], heap[smallest] = heap[smallest], heap[index]
        _sift_down(heap, smallest)  # 재귀적으로 아래로 이동
```

**시간복잡도**: O(log n) - 트리의 높이만큼 이동

# 11. Python heapq 모듈

Python은 최소 힙을 구현한 `heapq` 모듈을 제공합니다.

## 11.1 기본 사용법

```python
import heapq

# 12. 빈 힙 생성
heap = []

# 13. 요소 추가 (최소 힙)
heapq.heappush(heap, 5)
heapq.heappush(heap, 3)
heapq.heappush(heap, 7)
heapq.heappush(heap, 1)
print(heap)  # [1, 3, 7, 5] (힙 구조)

# 14. 최솟값 조회 (제거 X)
min_value = heap[0]
print(min_value)  # 1

# 15. 최솟값 제거 및 반환
min_value = heapq.heappop(heap)
print(min_value)  # 1
print(heap)       # [3, 5, 7]

# 16. 리스트를 힙으로 변환
numbers = [5, 3, 7, 1, 9, 2]
heapq.heapify(numbers)  # O(n) 시간
print(numbers)  # [1, 3, 2, 5, 9, 7] (힙 구조)
```

## 16.1 최대 힙 구현

Python의 heapq는 최소 힙만 제공하므로, 최대 힙은 값을 음수로 변환하여 구현합니다.

```python
import heapq

# 17. 최대 힙
max_heap = []

# 18. 요소 추가 (음수로 변환)
heapq.heappush(max_heap, -5)
heapq.heappush(max_heap, -3)
heapq.heappush(max_heap, -7)
heapq.heappush(max_heap, -1)
print(max_heap)  # [-7, -3, -5, -1]

# 19. 최댓값 제거 및 반환 (음수를 다시 양수로)
max_value = -heapq.heappop(max_heap)
print(max_value)  # 7
```

## 19.1 유용한 heapq 함수들

```python
import heapq

# 20. n개의 최솟값 찾기
numbers = [5, 3, 7, 1, 9, 2, 8, 4, 6]
smallest_3 = heapq.nsmallest(3, numbers)
print(smallest_3)  # [1, 2, 3]

# 21. n개의 최댓값 찾기
largest_3 = heapq.nlargest(3, numbers)
print(largest_3)  # [9, 8, 7]

# 22. 두 힙 병합
heap1 = [1, 3, 5]
heap2 = [2, 4, 6]
heapq.heapify(heap1)
heapq.heapify(heap2)

merged = []
while heap1 and heap2:
    if heap1[0] < heap2[0]:
        merged.append(heapq.heappop(heap1))
    else:
        merged.append(heapq.heappop(heap2))

merged.extend(heap1 or heap2)
print(merged)  # [1, 2, 3, 4, 5, 6]
```

# 23. 우선순위 큐 (Priority Queue)

우선순위 큐는 **각 요소가 우선순위를 가지며, 우선순위가 높은 요소가 먼저 나가는 자료구조**입니다. 힙으로 구현하면 효율적입니다.

## 23.1 우선순위 큐 구현

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.heap = []
        self.counter = 0  # 같은 우선순위일 때 삽입 순서 보장

    def push(self, item, priority):
        """우선순위와 함께 요소 추가 (낮은 값이 높은 우선순위)"""
        # (우선순위, 삽입순서, 값) 튜플로 저장
        heapq.heappush(self.heap, (priority, self.counter, item))
        self.counter += 1

    def pop(self):
        """가장 높은 우선순위 요소 제거 및 반환"""
        if not self.heap:
            raise IndexError("Priority queue is empty")
        priority, _, item = heapq.heappop(self.heap)
        return item

    def peek(self):
        """가장 높은 우선순위 요소 조회 (제거 X)"""
        if not self.heap:
            raise IndexError("Priority queue is empty")
        priority, _, item = self.heap[0]
        return item

    def is_empty(self):
        return len(self.heap) == 0

    def size(self):
        return len(self.heap)

# 24. 사용 예제
pq = PriorityQueue()
pq.push("작업 A", priority=3)
pq.push("작업 B", priority=1)  # 가장 높은 우선순위
pq.push("작업 C", priority=2)

print(pq.pop())  # "작업 B" (우선순위 1)
print(pq.pop())  # "작업 C" (우선순위 2)
print(pq.pop())  # "작업 A" (우선순위 3)
```

# 25. 실전 문제 해결

## 25.1 예제: 더 맵게

**문제**: 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 구하세요.
- 섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식 + (두 번째로 맵지 않은 음식 × 2)

```python
import heapq

def solution(scoville, K):
    """
    접근 방법: 최소 힙 활용
    - 최소 힙으로 가장 맵지 않은 음식 빠르게 찾기
    - 조건을 만족할 때까지 섞기 반복
    """
    heapq.heapify(scoville)  # 리스트를 힙으로 변환
    mix_count = 0

    while scoville[0] < K:
        # 음식이 1개만 남았는데 K 미만이면 불가능
        if len(scoville) < 2:
            return -1

        # 가장 맵지 않은 두 음식 꺼내기
        first = heapq.heappop(scoville)
        second = heapq.heappop(scoville)

        # 새로운 음식 만들어 추가
        new_scoville = first + (second * 2)
        heapq.heappush(scoville, new_scoville)

        mix_count += 1

    return mix_count

# 26. 테스트
scoville = [1, 2, 3, 9, 10, 12]
K = 7
print(solution(scoville, K))  # 2
# 27. 설명:
# 28. 1차: 1 + (2 × 2) = 5, [3, 5, 9, 10, 12]
# 29. 2차: 3 + (5 × 2) = 13, [9, 10, 12, 13]
# 30. 모든 음식이 7 이상
```

**시간복잡도**: O(n log n) - 최악의 경우 모든 음식을 섞음

## 30.1 예제: 디스크 컨트롤러

**문제**: 하드디스크가 작업을 수행하는 평균 시간을 최소화하세요.

```python
import heapq

def solution(jobs):
    """
    접근 방법: 우선순위 큐 (최소 힙)
    - 현재 시점에 요청된 작업 중 소요 시간이 짧은 것부터 처리
    - SJF (Shortest Job First) 스케줄링
    """
    jobs.sort()  # 요청 시간 순으로 정렬
    current_time = 0
    total_time = 0
    job_index = 0
    n = len(jobs)
    heap = []

    while job_index < n or heap:
        # 현재 시점까지 요청된 작업들을 힙에 추가
        while job_index < n and jobs[job_index][0] <= current_time:
            # (소요시간, 요청시간) 형태로 저장 (소요시간 기준 최소 힙)
            heapq.heappush(heap, (jobs[job_index][1], jobs[job_index][0]))
            job_index += 1

        if heap:
            # 소요 시간이 가장 짧은 작업 처리
            duration, request_time = heapq.heappop(heap)
            current_time += duration
            total_time += current_time - request_time
        else:
            # 처리할 작업이 없으면 다음 작업 요청 시간으로 이동
            current_time = jobs[job_index][0]

    return total_time // n

# 31. 테스트
jobs = [[0, 3], [1, 9], [2, 6]]
print(solution(jobs))  # 9
# 32. 설명:
# 33. 0ms: [0,3] 시작 → 3ms 완료 (대기: 3ms)
# 34. 3ms: [2,6] 시작 (소요시간 6 < 9) → 9ms 완료 (대기: 9-2=7ms)
# 35. 9ms: [1,9] 시작 → 18ms 완료 (대기: 18-1=17ms)
# 36. 평균: (3+7+17)/3 = 9
```

## 36.1 예제: 이중 우선순위 큐

**문제**: 최댓값과 최솟값을 모두 삭제할 수 있는 이중 우선순위 큐를 구현하세요.

```python
import heapq
from collections import defaultdict

def solution(operations):
    """
    접근 방법: 최소 힙과 최대 힙 동시 사용
    - 최소 힙: 최솟값 빠르게 제거
    - 최대 힙: 최댓값 빠르게 제거
    - 동기화: 삭제된 값은 양쪽에서 모두 제거
    """
    min_heap = []
    max_heap = []
    counter = defaultdict(int)  # 각 값의 개수 추적

    for op in operations:
        cmd, num = op.split()
        num = int(num)

        if cmd == 'I':
            # 삽입: 양쪽 힙에 모두 추가
            heapq.heappush(min_heap, num)
            heapq.heappush(max_heap, -num)
            counter[num] += 1

        elif cmd == 'D':
            if num == 1:
                # 최댓값 삭제
                while max_heap and counter[-max_heap[0]] == 0:
                    heapq.heappop(max_heap)
                if max_heap:
                    max_val = -heapq.heappop(max_heap)
                    counter[max_val] -= 1
            else:
                # 최솟값 삭제
                while min_heap and counter[min_heap[0]] == 0:
                    heapq.heappop(min_heap)
                if min_heap:
                    min_val = heapq.heappop(min_heap)
                    counter[min_val] -= 1

    # 유효한 값들만 남기기
    while min_heap and counter[min_heap[0]] == 0:
        heapq.heappop(min_heap)
    while max_heap and counter[-max_heap[0]] == 0:
        heapq.heappop(max_heap)

    if not min_heap or not max_heap:
        return [0, 0]

    return [-max_heap[0], min_heap[0]]

# 37. 테스트
operations = ["I 16", "I -5643", "D -1", "D 1", "D 1", "I 123", "D -1"]
print(solution(operations))  # [0, 0]

operations = ["I -45", "I 653", "D 1", "I -642", "I 45", "I 97", "D 1", "D -1", "I 333"]
print(solution(operations))  # [333, -45]
```

## 37.1 예제: K번째 큰 요소 찾기

**문제**: 정렬되지 않은 배열에서 K번째로 큰 요소를 찾으세요.

```python
import heapq

def find_kth_largest(nums, k):
    """
    접근 방법 1: 최소 힙 유지
    - 크기가 k인 최소 힙 유지
    - 힙의 최솟값이 k번째로 큰 값
    """
    heap = []

    for num in nums:
        heapq.heappush(heap, num)
        # 힙 크기가 k를 초과하면 최솟값 제거
        if len(heap) > k:
            heapq.heappop(heap)

    # 힙의 최솟값이 k번째로 큰 값
    return heap[0]

# 38. 다른 접근: nlargest 활용
def find_kth_largest_v2(nums, k):
    """
    접근 방법 2: heapq.nlargest 활용
    """
    return heapq.nlargest(k, nums)[-1]

# 39. 테스트
nums = [3, 2, 1, 5, 6, 4]
k = 2
print(find_kth_largest(nums, k))  # 5 (2번째로 큰 값)

nums = [3, 2, 3, 1, 2, 4, 5, 5, 6]
k = 4
print(find_kth_largest(nums, k))  # 4 (4번째로 큰 값)
```

# 40. 언제 힙을 사용하는가?

## 40.1 힙이 적합한 경우

- **최댓값/최솟값을 자주 찾을 때**
  - K번째로 큰/작은 요소 찾기

- **우선순위 기반 처리**
  - 작업 스케줄링
  - 이벤트 관리

- **정렬이 필요하지만 전체 정렬은 비효율적일 때**
  - 상위 K개만 필요한 경우
  - 힙 정렬 (Heap Sort)

- **중간값 유지**
  - 두 개의 힙으로 중간값 추적

- **다익스트라 알고리즘**
  - 최단 경로 찾기

## 40.2 힙이 부적합한 경우

- **임의의 요소 검색**
  - O(n) 시간 소요, 해시 테이블이 더 적합

- **모든 요소 정렬 필요**
  - 일반 정렬 알고리즘 사용

- **FIFO/LIFO 순서 필요**
  - 큐/스택 사용

# 41. 핵심 정리

:::div{.callout}
<highlight>**힙 핵심 포인트**</highlight>

**기본 개념**:
- 완전 이진 트리 기반
- 부모 ≤ 자식 (최소 힙) 또는 부모 ≥ 자식 (최대 힙)
- 배열로 효율적 표현

**시간복잡도**:
- 최댓값/최솟값 조회: O(1)
- 삽입: O(log n)
- 삭제: O(log n)
- 힙 생성 (heapify): O(n)

**Python 구현**:
- `heapq` 모듈 사용 (최소 힙)
- 최대 힙: 음수로 변환
- `heappush`, `heappop`, `heapify`

**활용 시나리오**:
- 우선순위 큐
- K번째 큰/작은 요소
- 작업 스케줄링
- 최단 경로 알고리즘

**코딩테스트 팁**:
- 최댓값/최솟값을 반복적으로 찾는다면 힙 고려
- 정렬 대신 힙으로 O(n log n) → O(n log k) 개선 가능
- 이중 우선순위 큐: 최소 힙 + 최대 힙 동시 사용
:::

# 42. 연습 문제

다음 문제들을 풀어보며 힙 개념을 확실히 다져보세요:

1. **배상 비용 최소화**: 작업의 배상 비용을 최소화하는 순서 찾기
2. **야근 지수**: 남은 일을 분배하여 야근 지수 최소화
3. **라면 공장**: 재고가 떨어지지 않도록 공급 받기
4. **중간값 찾기**: 스트림에서 계속 추가되는 수의 중간값 찾기
5. **회의실 배정**: 최소 회의실 개수 구하기

---

# 43. Chapter 3 마무리

이번 장에서는 코딩테스트에서 가장 중요한 자료구조들을 학습했습니다:

1. **배열과 리스트**: 가장 기본적인 자료구조, 인덱스 기반 빠른 접근
2. **스택과 큐**: LIFO와 FIFO 구조, 순서가 중요한 문제 해결
3. **해시 테이블**: 빠른 검색과 데이터 매핑, O(1) 시간복잡도
4. **트리와 그래프**: 계층적/관계적 데이터 표현, 탐색 알고리즘의 기초
5. **힙**: 우선순위 관리, 최댓값/최솟값 빠른 접근

:::div{.callout}
<highlight>**자료구조 선택 가이드**</highlight>

문제를 풀 때 다음을 고려하여 자료구조를 선택하세요:

- **빠른 검색 필요?** → 해시 테이블 (dict, set)
- **순서 중요?** → 리스트, 스택, 큐
- **최댓값/최솟값 자주 찾기?** → 힙
- **계층 구조?** → 트리
- **관계 표현?** → 그래프
- **중간 삽입/삭제 빈번?** → 연결 리스트, 덱

각 자료구조의 시간복잡도를 이해하고, 문제의 제약 조건에 맞는 최적의 자료구조를 선택하는 것이 중요합니다!
:::

다음 장에서는 이러한 자료구조를 활용한 다양한 알고리즘을 학습하겠습니다!
